/*****
两个字符串的最小ASCII删除和

给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。

示例 1:

输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
示例 2:

输入: s1 = "delete", s2 = "leet"
输出: 403
解释: 在 "delete" 中删除 "dee" 字符串变成 "let"，
将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。
结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。
注意:

0 < s1.length, s2.length <= 1000。
所有字符串中的字符ASCII值在[97, 122]之间。

思路：
很经典的一道DP，和“编辑的最小代价类似”。一般求什么就设DP什么，那么设置二维数组int dp[n][m]。
设状态dp[i][j]表示为使s1前i个字符和s2前j个字符删除部分字母所能使两字符串相等的ascii码总和，那么状态转移方程为:
dp[i][j] = dp[i - 1][j - 1](s1[i] = s2[j]),
 或min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j], dp[i - 1][j - 1] + s1[i] + s2[j])。
在做的过程中需要注意初始化问题。

下面的是从末尾开始，思路相反：
  假设dp[i][j]，其中[i]表示s1的第i个字符之后的子串，[j]表示s2的第j个字符之后的子串，
则dp[i][j]表示这两个子串的找到使两个字符串相等所需删除字符的ASCII值的最小和。

if(s1[i-1]==s2[j-1])  ，那么当前字符不需删除， dp[i][j]=dp[i+1][j+1]。
else ，删除s1[i-1]，或者s2[j-1]。于是dp[i][j]=min(dp[i+1][j]+s1[i-1], dp[i][j+1]+s2[j-1])。
找到递推关系之后，再找边界条件：

两个字符串为空，dp[size1][size2]=0;
其中一个字符串为空，dp[] = (另一个字符串全部删除，即另一个字符串所有字符总和)。
**/
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        final int l1 = s1.length();
        final int l2 = s2.length();
        
        int[][] dp = new int[l1+1][l2+1];
        dp[l1][l2] = 0;
        for(int i=l1-1;i>=0;i--) {//先将最后一列的初值按照s2字符串赋值
            dp[i][l2] = dp[i+1][l2] + s1.charAt(l1-i-1); 
        }
        for(int j=l2-1;j>=0;j--) {//先将最后一行按照s1字符串赋值
            dp[l1][j] = dp[l1][j+1] + s2.charAt(l2-j-1);
        }
        
        for(int i=l1-1;i>=0;i--) {
            for(int j=l2-1;j>=0;j--) {//由最右下角元素开始
                if(s1.charAt(l1-i-1)==s2.charAt(l2-j-1)){//s1字符不变与s2字符最后一个往前判断若是相同则同行前一位等于后一位
                    dp[i][j] = dp[i+1][j+1];
                } else{//状态方程
                    dp[i][j] = Math.min(dp[i+1][j]+s1.charAt(l1-i-1),dp[i][j+1]+s2.charAt(l2-j-1));
                }
            }
        }
        return dp[0][0];
    }
}