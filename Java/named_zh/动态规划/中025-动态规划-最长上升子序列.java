/**
*最长上升子序列-300
给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

*/
class Solution {
	/**
	* 解法（O(n log n)）：使用dp数组存最长的子序列，每次遍历新元素去找该元素应该插入的位置：
	* 1）比原dp都大那么就是新增代表x==len那么dp的长度变大
	* 2）能在dp数组找到，代表里面的内容能变小，将其中部分内容替换，不用担心替换后的dp的x-len内容是原最大的子序列，
	* 因为如果是能替换的dp子序列中的那么最大的长度是不变的（这种情况没办法更新最大值），
	* 新增的则确实之前有那么长的子序列可以多加1个变更长。
	*/
    public int lengthOfLIS(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int n=nums.length;
        int[] dp=new int[n];
        int len=0;
        for(int i=0;i<n;i++){
            int x=Arrays.binarySearch(dp,0,len,nums[i]);//当前元素在dp数组应该插入的位置
            if(x<0){
                x=-(x+1);//小于0代表的是不在dp的范围内，所以是新增
            }
            dp[x]=nums[i];//在范围内直接替换，不在就是新增
            if(x==len){
                len++;//代表当前元素比原最长子序列最大值大，那么dp的最长子序列长度变大
            }
        }
        return len;
    }
}