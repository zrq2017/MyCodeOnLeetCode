/*****
爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

分析：
假设从底走到第n级的走法有dp[n]种，走到第n级有两个方法，一个是从(n-1)级走一步，
另一个是从第(n-2)级走两步，前者有dp[n-1]种方法，后者有dp[n-2]种方法，
所以有dp[n] = dp[n-1] + dp[n-2],还有dp[0]=0,dp[1]=1,dp[2]=2。

思路：
如果n==1，显然只有从0->1一种方法f(1)=1； 
如果n==2，那么有0->1->2、0->2两种方法f(2)=2; 
如果n==3,那么可以先爬到第1阶，然后爬两个台阶，或者先爬到第二阶，然后爬一个台阶，显然f(3)=f(2)+f(1); 
…… 
推广到一般情况，对于n(n>=3)个台阶,可以先爬到第n-1个台阶，然后再爬一个台阶，或者先爬到n-2个台阶，然后爬2个台阶，因此有f(n)=f(n-1)+f(n-2)。 
那么动态规划的递推公式和边界条件都有了，即： 
f(n){=1(n=1)
	{=2(n=2)
	{=f(n-1)+f(n-2)(n>2)

#####实动态规划解题的主要思想就是找出递推式，然后利用子问题的解来求最后的最优解
**/
class Solution {
    public int climbStairs(int n) {
        if(n==1){
            return 1;
        }else if(n==2){
            return 2;
        }else{
            int s1 = 1;//dp[i-1]
            int s2 = 2;//dp[i]
            int si = 0;//dp[i+1]
            for(int i=3;i<=n;i++){
                si= s1+s2;
                s1=s2;
                s2=si;
            }
            return si;
        }
    }
}