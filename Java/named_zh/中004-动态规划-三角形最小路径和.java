/*****
三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
**/
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        /**
        自底向上动态规划, dp[i]表示到第i行时的最小路径和, 先从底层
        开始判断, 每向上一层后该层的数据无需再使用可以直接覆盖, 所以
        可以把空间复杂度优化到O(N), 但是要注意覆盖时的顺序
        **/
        int n = triangle.size();
        if(n < 1) return 0;
        int[] dp = new int[n+1];//记录每一层的最小值，多一个控制最后一层索引不越界
        for(int i = n-1; i >= 0; --i) {//从最后一层开始往上
            int size = triangle.get(i).size();//每层的元素大小
            for(int j = 0; j < size; ++j){
                //最后一层的时候自动将最后一层的值全部赋值进入dp数组
                //非最后一层时，取下一层相邻的两个中最小的计算加入结果数组，并加上当前数，直到第一层
                dp[j] = Math.min(dp[j], dp[j+1]) + triangle.get(i).get(j);
            }
        }
        return dp[0];
    }
}